---
description: Rules for how to comment new and existing code
alwaysApply: false
---
# Goals

* Prefer obvious code; comment only what code can’t say clearly.
* Explain **why** and **when**, not **what** the next line does.
* Optimize for future readers (context, constraints, trade-offs).

# What to Comment

* **Module/Hook/Component header**: purpose, responsibilities, inputs/outputs, high-level flow.
* **Non-obvious functions/effects**: concurrency, lifecycle, streaming, caching, parsing, memoization.
* **Invariants & contracts**: assumptions, pre/post-conditions, error boundaries, rate limits, timeouts.
* **Decision points**: why this approach vs alternatives; trade-offs and constraints.
* **Side effects**: subscriptions, network calls, event listeners, storage, AbortControllers.
* **Data formats**: streaming chunk shape, partial JSON structure, versioning.
* **Edge cases**: cancellation, retries, malformed payloads, race conditions, unmount cleanup.
* **References**: spec links, tickets, designs (keep stable URLs only).

# What Not to Comment

* Obvious code or restating the implementation (“increment i”).
* Personal notes, jokes, or transient debug info.
* Internal team gossip or secrets; never include tokens/IDs.
* Comments that will rot when names change—prefer refactorable code.

# Comment Styles

* **JSDoc for public APIs** (hooks, exported utils):

  * Summary (one line).
  * Details (1–3 lines: responsibilities & behavior).
  * `@param` (type + meaning), `@returns`, concise `@example`.
  * `@remarks` for caveats: single-active stream, cleanup rules, partial parsing.
* **Block comment for rationale** above tricky logic, each block separated by an emptly line:
  * **Summary**: one sentence.
  * **Rationale**: bullets on intent & trade-offs.
  * **Mechanism**: bullets on how it works.
  * **References**: stable links (spec, repo).
* **Inline comments**: only for non-obvious expressions; keep to one short line.

# Placement & Structure

* Place module header at top; public API JSDoc directly above export.
* Put rationale blocks **above** effects, async flows, or parsers.
* Keep comments close to code they explain; avoid end-of-line noise.
* Use consistent headings in blocks: **Summary / Rationale / Mechanism / References**.

# Tone & Format

* Be precise, declarative, and brief; prefer bullets over paragraphs.
* Use present tense (“Handles…”, “Ensures…”).
* Keep lines short; wrap at \~100 chars.
* Use code identifiers in backticks; avoid slang.

# Concurrency & Streaming Notes

* Document cancellation strategy (e.g., `AbortController`) and single-flight rules.
* State ordering guarantees, buffering, backpressure, and partial parse behavior.
* Clarify cleanup on unmount and on error paths.

# Error Handling

* Specify what is surfaced to callers (`error` state), what’s retriable, and when streaming stops.
* Note known failure modes (network, server-sent errors, malformed chunks).

# Maintenance & TODOs

* Use `// TODO(username, yyyy-mm-dd): ...` for actionable work.
* Use `// NOTE:` for non-actionable context worth keeping.
* Remove comments when they stop adding value; keep code and comments in sync.
