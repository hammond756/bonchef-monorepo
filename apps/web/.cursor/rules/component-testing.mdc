---
description: When you create or update a component, follow these rules to ensure it is properly tested.
alwaysApply: false
---
## 1. What to test

* You test behaviour, not implementation
* Never assert on console output

## 2. Tooling

- **Test Runner:** [Vitest](https://vitest.dev/)
- **Testing Framework:** [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- **DOM Assertions:** [`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom)
- **User Interactions:** [`@testing-library/user-event`](https://testing-library.com/docs/user-event/intro)

---

## 3. File Structure

All component unit tests should reside next to the component they're testing. This way it's easy to see
which components are missing tests and to find the test file to update when updating a component.

- **Example:** A test for `src/components/recipe/recipe-card.tsx` should be located at `src/components/recipe/recipe-card.test.tsx`.
- **Naming Convention:** Use kebab-case for the test file name, followed by `.test.tsx`.

---

## 4. Writing Tests

### The AAA Pattern
Structure every test using the **Arrange, Act, Assert** pattern:
1.  **Arrange:** Set up the test. Render the component with the necessary props and mocks.
2.  **Act:** Interact with the component. Simulate user events like clicks or typing.
3.  **Assert:** Check the result. Verify that the component's output matches the expected outcome.

Tests should focus on the behaviour of the component, and how users percieve and interact with it. 
You should avoid testing and asserting on implementation details.

### Querying Elements
Always use the most semantic queries possible, following the recommended priority:
1.  `getByRole`: For interactive elements (buttons, links, etc.).
2.  `getByLabelText`: For form fields.
3.  `getByPlaceholderText`
4.  `getByText`
5.  `getByDisplayValue`

Avoid `getByTestId` unless no other semantic query is suitable.

### Simulating User Events
Always use `userEvent.setup()` to simulate user interactions. It provides a more realistic simulation of browser behavior than `fireEvent`.

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

test('should handle click', async () => {
  const user = userEvent.setup();
  const onClick = vi.fn();
  render(<Button onClick={onClick}>Click Me</Button>);

  const button = screen.getByRole('button', { name: /click me/i });
  await user.click(button);

  expect(onClick).toHaveBeenCalledTimes(1);
});
```

---

## 5. Mocking

To keep tests fast and isolated, mock any external dependencies that are not directly related to the component's UI logic. This includes:

-   API calls (e.g., Supabase client)
-   Hooks that provide external context (e.g., `useUser`)
-   Browser/Next.js modules (e.g., `next/navigation`)

Use `vi.mock()` at the top of your test file.

**Example (from our setup):**
We mocked the `useUser` hook to prevent it from making a real network request to Supabase during the `RecipeCard` test.

```ts
// src/components/recipes/recipe-card.test.tsx
vi.mock('@/hooks/use-user', () => ({
    useUser: () => ({
        user: { id: '1', email: 'test@example.com' },
        isLoading: false,
    }),
}));
```

If a mock is used in more than 2 test files, factor it out into a mock module. That way they stay maintainable when their API changes in the future.

---

## 6. Testing data-fetching hooks with SWR

```tsx
// src/hooks/use-comments.test.tsx
import * as commentsClient from "@/lib/services/recipe-imports-job/client"

const mockComments = [
    { id: "1", text: "Hi! That's delicious" },
    { id: "2", text: "Would love to eat this" },
]

// Mock out dependencies
vi.mock("@/lib/services/comments/client")
vi.mock("@/hooks/use-user", () => ({
    useUser: () => ({ user: { id: "user-123" } }),
}))

const withSWRConfig = (hookFn: () => any) =>
    renderHook(hookFn, {
        wrapper: ({ children }: { children: React.ReactNode }) => (
            <SWRConfig value={{ provider: () => new Map() }}>{children}</SWRConfig>
        ),
    })

describe("useComments", () => {
    beforeEach(() => {
        vi.resetAllMocks()
    })

    it("should fetch and return comments", async () => {
        // @ts-ignore
        commentsClient.listComments.mockResolvedValue({
            success: true,
            data: mockComments,
        })

        const { result } = withSWRConfig(() => useComments())

        await waitFor(() => {
            expect(result.current.comments).toEqual(mockComments)
            expect(result.current.isLoading).toBe(false)
        })
    })
```

---

## 6. Continuous Integration (CI)

-   The CI workflow at `.github/workflows/ci.yml` automatically runs all unit tests on every pull request to the `main` branch.
-   **Tests must pass** before a pull request can be merged.
-   All new features or bug fixes should be accompanied by relevant tests.
